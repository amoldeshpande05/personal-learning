Common problems on dynamic programming:

- calculate 40th number of fibonacci sequence
- count number of different ways to move through a 6*9 grid
- Given a set of coins, how we make change of 27 cents in least number of coins
- Given a set of subStrings, what are the possible ways to construct the string potentpot



There is a simple program to find the space complexity and time complexity

dib(n):
    if n<=1:
        return
    dib(n-1)
    dib(n-1)


this function, goes on increasing exponentially, so the time complexity is the O(2^n)
Interestingly the space complexity is not O(n^2), it is O(n), because everytime the function is pushed into the stack, the other values are popped from the stack so living it O(n)



lib(n):
    if n<=1:
        return
    lib(n-2)
    lib(n-2)

timecomplexity  : O(2^n/2)
spaceComplexity : O(n)


def fibonacci(n):
    if n <= 2:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)

Here it has both, n-1 as well as n-2, so the time compplexity should be somewhere in the middle
O(2^n) - time complexity
O(n) - space complexity



DYNAMIC PROGRAMMING MEMORIZATION

If we check at the tree, the values are repeating many times, so to over come that, there is a concept of memorization, where we store the result in intermediate variables and then save it in a memory, when there is a requirment of that particular key, then return it from the memorization.
def fibonacci(n):
    if n <= 2:
        return 1
    if n in result.keys():
        return result[n]
    print(n)
    result[n] = fibonacci(n-1) + fibonacci(n-2)
    return result[n]


    so by this the time complexity is O(2n) which we can reduce it to O(n)
    So this show dynamic program brought the exponentiallytime complexity to the O(n)



2nd program
How many unique way we can move through a grid of 2*3

memo = {}
def gridTraveler(m,n):
    if m == 0 or n == 0:
        return 0
    if m == 1 and n == 1:
        return 1
    if (m,n) in memo.keys():
        return memo[(m,n)]
    memo[(m,n)] = gridTraveler(m-1,n) + gridTraveler(m,n-1)
    return memo[(m,n)]


Like the program, the approach is that, when the problem is given, try to write a logic with tree strucutre, for this problem, consider the left tree which represents choice of going down, the right subtree will go to the right. And add both the end result values

The time complexity is O(n+m) and O(n*m) space complexity


1. Make it work:
    - visualize the problem as tree
    - implement the tree using recursion
    - test it
2. Make it effecient
    - add a memo object
    - add a base case to return memo values
    - store return value in the memo